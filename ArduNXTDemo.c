#pragma config(Sensor, S1,     ArduNXT,             sensorI2CCustomFastSkipStates)
#pragma config(Motor,  motorA,          Flipper,       tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          Right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          Left,          tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////////
//
//                           ArduNXT Examples
//                           ================
//
// Based on I2C Coding Source Code Examples
//
////////////////////////////////////////////////////////////////////////////////////////

#pragma platform(NXT)

#define FLIP_ANGLE  (90)

// ArduNXT Addresses
const int kServoRegisterIndex = 0x4B;    // Servo outputs x4

int FlipState = 0;

//////////////////////////////////////////////////////////////////////////////////////////
//
//             initializeI2CSensor(TSensors nPortIndex, const bool bFastI2C)
//
// Initializes an I2C sensor. 'bFastI2C' is a flag to indicate whether standard speed I2C
// (i.e. one byte transferred every 1 to 2 milliseconds using 12 KHz clock) or fast speed
// transmission should be used with the sensor.
//
// Fast speed is about five times faster than standard. It is suitable for sensors that
// have hardware I2C support rather than a bit-banged I2C implementation.
//
//////////////////////////////////////////////////////////////////////////////////////////

void initializeI2CSensor(const tSensors nPortIndex, const bool bFastI2C)
{
  SensorType[nPortIndex] = bFastI2C ? sensorI2CCustomFast : sensorI2CCustom;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//                waitForI2CReply(TSensors nPortIndex, const int nReplyLength)
//
// Function will delay waiting for last I2C transaction to finish.
//
//////////////////////////////////////////////////////////////////////////////////////////

bool waitForI2CReply(tSensors nPortIndex, const int nReplyLength)
{
	while (nI2CStatus[nPortIndex] == STAT_COMM_PENDING)
		wait1Msec(1);

	if (nI2CBytesReady[nPortIndex] != nReplyLength)
		return false;

	return true;
}


//
// Alternate version showing more complicated error checking
//

bool checkErrorStatus(tSensors nPortIndex, const int nReplyLength)
{
	while (nI2CStatus[nPortIndex] == STAT_COMM_PENDING)
		wait1Msec(1); // Waiting for I2C transaction to complete

	//
	// Handle all possible return status. You may want to customize the
	// code for your particular situation.
	//
	switch (nI2CStatus[nPortIndex])
	{
	case NO_ERR:
		return true;

	case STAT_COMM_PENDING:
		// Shouldn't reach here because of preceding 'while' clause
		return false;

	case ERR_COMM_CHAN_NOT_READY:
		// Sensor is not configured for I2C messaging.
		return false;

	case ERR_COMM_BUS_ERR:
		// re-initialize sensor. An I2C messaging error occurred.
		return false;

	default:
		// "Illegal" value
		return false;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//                        Send a Message via I2C
//
// Sends an arbitrary 4-byte message over an I2C port. It would be easy to modify for
// messages of different length. Simply adjust the function parameters and the initialization
// of the 'nMsg' array.
//
// You'll have to poll the status of the I2C communications channel to tell when the
// I2C transaction is complete.
//
// Usually when writing to device the reply length will be zero.
//
//////////////////////////////////////////////////////////////////////////////////////////

bool sendI2CMessage(tSensors nPortIndex, byte kRegisterIndex, byte nByte1, byte nByte2, byte nByte3, byte nByte4)
{
	const int kI2CAddress    = 0x02;    // You may want to make this a function parameter

	const byte nMsg[] =
	{
		2 + 4,               // This is length field for transmitted message.
		kI2CAddress,         // The I2C address of the device. Almost all devices use value '0x02'
		kRegisterIndex,      // The internal register index within the sensor to start writing at.
		nByte1,
		nByte2,
		nByte3,
		nByte4
	};

	if (nI2CStatus[nPortIndex] == STAT_COMM_PENDING)
		return false;   // Can't send message to a busy device

	sendI2CMsg(nPortIndex, nMsg[0], 0);
	return true;
}


bool sendArduNXTServo(tSensors nPortIndex, byte nByte1, byte nByte2, byte nByte3, byte nByte4)
{
  return(sendI2CMessage(nPortIndex, kServoRegisterIndex, nByte1, nByte2, nByte3, nByte4));
}


//////////////////////////////////////////////////////////////////////////////////////////
//
//                           Read from an I2C Device
//
// Sends a message to I2C sensor to read data from the device. You'll have to poll the
// status of the I2C communications channel to tell when the 'read' is complete.
//
//////////////////////////////////////////////////////////////////////////////////////////

bool sendSensorRead(tSensors nPortIndex, const ubyte &nSendMsg, const int nReplyLength)
{
	if (nI2CStatus[nPortIndex] == STAT_COMM_PENDING)
		return false;   // Can't send message to a busy device

	sendI2CMsg(nPortIndex, nSendMsg, nReplyLength);
	return true;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//                        readI2CReply(TSensors nPortIndex)
//
// Collects the reply bytes from an I2C message.
//
//////////////////////////////////////////////////////////////////////////////////////////

bool readSensorReply(tSensors nPortIndex, ubyte &pReplyMsg, const int nReplyLength)
{
	if (!waitForI2CReply(nPortIndex, nReplyLength))
	{
	  return false;
	}

	readI2CReply(nPortIndex, pReplyMsg, nReplyLength);
	return true;
}


#define PWM_CENTRE    (1500)
#define PWM_THRESHOLD (50)
#define PWM_RANGE     (4)   // Scale factor to get a range of 100

// Steering -or one channel of tank drive
// returns a value from +100 to -100
// with a deadband around 0
int PWM2Motor(int nPWM)
{
  if (abs(nPWM - PWM_CENTRE) < PWM_THRESHOLD)
  {
    return (0); // No turn
  }
  else
  {
    return (((nPWM - PWM_CENTRE) / PWM_RANGE));
  }
}

// Throttle
int PWM2Power(int nPWM)
{
  if (abs(nPWM - PWM_CENTRE) < PWM_THRESHOLD)
  {
    return (0);
  }
  else
  {
    return (((nPWM - PWM_CENTRE)) / PWM_RANGE);
  }
}


int ubyte2int(ubyte uVal)
{
  int iValue = uVal;

  if (uVal >= 128)
  {
    // Values >= 128 are negative (2s complement values)
    iValue -= 256;
  }
  return (iValue);
}



////////////////////////////////////////////////////////////////////////////////////////////
//
//          Sample Task to Continuously read the sensor characteristics
//
////////////////////////////////////////////////////////////////////////////////////////////

void ReadGPS()
{
	const int kI2CAddress    = 0xB0;    // You may want to make this a function parameter
	const int kRegisterIndex = 0x6F;    // You may want to make this a function parameter

	unsigned long u24Time = 0;
  unsigned char Servo2 = 0;
  unsigned char Servo3 = 0;
  unsigned char Servo4 = 0;

	static const ubyte nReadRegisters[] =
	{
		2,                   // This is length field for transmitted message.
		kI2CAddress,         // The I2C address of the device. Almost all devices use value '0x02'
		kRegisterIndex,      // The internal register index within the sensor to start writing at.
	};

	const int kReplyLength = 5;
	ubyte nReply[kReplyLength];

  while (!sendSensorRead(S1, nReadRegisters, kReplyLength))
  {
    // wait until we can send the request to read data
  }

  int nReadTime = nSysTime;

  while (!readSensorReply(S1, (ubyte *)nReply, kReplyLength))
  {
    // wait for reply to arrive
    if ((nSysTime - nReadTime) > 100)
    {
      // if we haven't got a reply after 100mS then we are not going to get one.
      break;
    }
  }

  // Signed values
  nxtDisplayTextLine(3, "Time: %d %d", nReply[0], nReply[4]);
}


void flip()
{
  nxtDisplayTextLine(3, "Flip");

  //nMotorEncoder[Flipper] = 0;  //clear the LEGO motor encoders

  nMotorEncoderTarget[Flipper] = FLIP_ANGLE; //set the target stoping position

  motor[Flipper] = 100; //turn both motors on at 30 percent power

  while (nMotorRunState[Flipper] != runStateIdle) //while the encoder wheel turns
  {
    // This condition waits for motor to come to an idle position.
    // and then jumps out of the loop
  }

  motor[Flipper] = 0; //turn motor off

  FlipState = TRUE;
  nxtDisplayTextLine(3, "Flipped");

//wait1Msec(3000);  // wait 3 seconds to see feedback on the debugger screens
                    // open the "NXT Devices" window to see the distance the encoder spins.
                    // the robot will come to a stop at the nMotorEncoderTarget position.
}

void flop()
{
  nxtDisplayTextLine(3, "Flop");

//nMotorEncoder[Flipper] = 0;  //clear the LEGO motor encoders

  nMotorEncoderTarget[Flipper] = FLIP_ANGLE; //set the target stoping position

  motor[Flipper] = -50; //turn both motors on at 30 percent power

  while (nMotorRunState[Flipper] != runStateIdle) //while the encoder wheel turns
  {
    // This condition waits for motor to come to an idle position.
    // and then jumps out of the loop
  }

  motor[Flipper] = 0; //turn motor off

  FlipState = false;
  nxtDisplayTextLine(3, "Flopped");

//wait1Msec(3000);  // wait 3 seconds to see feedback on the debugger screens
                    // open the "NXT Devices" window to see the distance the encoder spins.
                    // the robot will come to a stop at the nMotorEncoderTarget position.
}

task main()
{
	const int kI2CAddress    = 0xB0;    // You may want to make this a function parameter
	const int kRegisterIndex = 0x63;    // You may want to make this a function parameter

	unsigned char Servo1 = 0;
  unsigned char Servo2 = 0;
  unsigned char Servo3 = 0;
  unsigned char Servo4 = 0;

	static const ubyte nReadRegisters[] =
	{
		2,                   // This is length field for transmitted message.
		kI2CAddress,         // The I2C address of the device. Almost all devices use value '0x02'
		kRegisterIndex,      // The internal register index within the sensor to start writing at.
	};

	const int kReplyLength = 4;         // You might want to make this a function parameter.
	int nReply[kReplyLength];

	int Direction = 0;
  initializeI2CSensor(ArduNXT, true);

  nMotorEncoder[Flipper] = 0;  //clear the LEGO motor encoders

  //nSyncedMotors = synchBC; //motor B is the master, motor C is the slave
  nPidUpdateInterval = 10;  // ms

  while (true)
  {
    // Update Servo positions
//  sendI2CMessage(ArduNXT, 0, Servo1++, Servo2--, Servo3++, Servo4--);

    nxtDisplayBigTextLine(0, "ArduNXT: %d", (int)Servo1);

    // TODO add timeout/retry mechanism
    while (!sendSensorRead(S1, nReadRegisters[0], kReplyLength<<1))
    {
      // wait until we can send the request to read data
    }

    int nReadTime = nSysTime;

    while (!readSensorReply(S1, (ubyte *)nReply[0], kReplyLength<<1))
    {
      // wait for reply to arrive
      if ((nSysTime - nReadTime) > 100)
      {
        // if we haven't got a reply after 100mS then we are not going to get one.
        break;
      }
    }

    // Signed values
    nxtDisplayTextLine(4, "Ch 0: %d", nReply[0]);
    nxtDisplayTextLine(5, "Ch 1: %d", nReply[1]);
    nxtDisplayTextLine(6, "Ch 2: %d", nReply[2]);
    nxtDisplayTextLine(7, "Ch 3: %d", nReply[3]);

    // Control the drive from the Radio Control
    nPidUpdateInterval
    if (0 <= PWM2Motor(nReply[1]))
    {
      if (Direction != 1)
      {
        motor[motorC] = 0;
        nSyncedMotors = synchBC; //motor B is the master, motor C is the slave
        Direction = 1;
      }
      nMotorEncoder[motorB] = 0; //reset the value of motorB's encoder to zero
      int Steering = 100 - 2 * PWM2Motor(nReply[1]); //motors move at % alignment to each other
      nSyncedTurnRatio  = Steering;
      motor[motorB] = PWM2Power(nReply[2]);
    }
    else
    {
      if (Direction != -1)
      {
        motor[motorB] = 0;
        nSyncedMotors = synchCB;
        Direction = -1;
      }
      nMotorEncoder[motorC] = 0; //reset the value of motorC's encoder to zero
      int Steering = 100 + 2 * PWM2Motor(nReply[1]); //motors move at % alignment to each other
      nSyncedTurnRatio  = Steering;
      motor[motorC] = PWM2Power(nReply[2]);
    }


    if (nReply[3] > 1600)
    {
      // Raise Flipper
      if (!FlipState) flip();
    }
    else if (FlipState)
    {
      flop();
    }

    // ReadGPS();

    wait1Msec(100);
  }
}
