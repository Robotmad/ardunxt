#pragma config(Sensor, S1,     ArduNXT,             sensorI2CCustomFastSkipStates)
#pragma config(Motor,  motorA,          Flipper,       tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          Right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          Left,          tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////////
//
//                           ArduNXT Examples
//                           ================
//
// Based on I2C Coding Source Code Examples
//
////////////////////////////////////////////////////////////////////////////////////////

#pragma platform(NXT)

#define MAX_NUM_RCCHANNELS    (7)       // Maximum number of Remote Control Input Channels

// ArduNXT Device I2C Address
#define ARDUNXT_I2C_ADDR      (0xB0)    // When used in Mindsensors NXT Servo Sensor compatibility mode

// ArduNXT Address Map
// ===================
//
#define ARDUNXT_CONFIG        (0x40)    // Configuration register
#define ARDUNXT_CMD           (0x41)    // Command register

//
// Servo Channel Addresses are compatible with Mindsensors NXT Servo Sensor
//
// Full resolution position register, can be read and written (value is 2 bytes, 16-bit, pulse width in uS)
#define ARDUNXT_SERVO_CHAN1   (0x42)    // Servo Channel 1 LSB (MSB is at address+1)
#define ARDUNXT_SERVO_CHAN2   (0x44)    // Servo Channel 1 LSB
#define ARDUNXT_SERVO_CHAN3   (0x46)    // Servo Channel 1 LSB
#define ARDUNXT_SERVO_CHAN4   (0x48)    // Servo Channel 1 LSB

// Quick position register, can only be written (value is single byte pulse width in units of 10uS)
#define ARDUNXT_QPOS_CHAN1    (0x5A)    // Servo channel 1 quick position
#define ARDUNXT_QPOS_CHAN2    (0x5B)    // Servo channel 2 quick position
#define ARDUNXT_QPOS_CHAN3    (0x5C)    // Servo channel 3 quick position
#define ARDUNXT_QPOS_CHAN4    (0x5D)    // Servo channel 4 quick position


//
// Remote Control Input Channels, read only (16bit unsigned pulse width in uS)
//
#define ARDUNXT_RC_CHAN1      (0x62)    // Remote Control Channel 1 LSB (MSB is at address+1)
#define ARDUNXT_RC_CHAN2      (0x64)    // Remote Control Channel 2 LSB
#define ARDUNXT_RC_CHAN3      (0x66)    // Remote Control Channel 3 LSB
#define ARDUNXT_RC_CHAN4      (0x68)    // Remote Control Channel 4 LSB
#define ARDUNXT_RC_CHAN5      (0x6A)    // Remote Control Channel 5 LSB
#define ARDUNXT_RC_CHAN6      (0x6C)    // Remote Control Channel 6 LSB
#define ARDUNXT_RC_CHAN7      (0x6E)    // Remote Control Channel 7 LSB


//
// Remote Control Input Channels, read only (8bit signed position)
//
#define ARDUNXT_RCPOS_CHAN1   (0x70)    // Remote Control Channel 1
#define ARDUNXT_RCPOS_CHAN2   (0x71)    // Remote Control Channel 2
#define ARDUNXT_RCPOS_CHAN3   (0x72)    // Remote Control Channel 3
#define ARDUNXT_RCPOS_CHAN4   (0x73)    // Remote Control Channel 4
#define ARDUNXT_RCPOS_CHAN5   (0x74)    // Remote Control Channel 5
#define ARDUNXT_RCPOS_CHAN6   (0x75)    // Remote Control Channel 6
#define ARDUNXT_RCPOS_CHAN7   (0x76)    // Remote Control Channel 7

#define ARDUNXT_MUX_MODE      (0x77)    // Hardware multiplexer mode (0=Radio Control, 1=NXT Control)

//
// GPS Data Block
//
#define ARDUNXT_GPSDATA       (0x78)    // GPS Data Block (start address)
#define ARDUNXT_GPSSIZE       (0x12)    // Size of the complete data block
#define ARDUNXT_GPSTIME       (0x78)    // Time in milliseconds (Time of Week)
#define ARDUNXT_GPSLAT        (0x7C)    // Latitude (min/10000)
#define ARDUNXT_GPSLONG       (0x80)    // Longitude (min/10000)
#define ARCUNXT_GPSALT        (0x84)    // Altitude (m/10)
#define ARDUNXT_GPSSPEED      (0x86)    // Speed (cm/s)
#define ARDUNXT_GPSHEAD       (0x88)    // Heading (degrees/100)


//
// Configuration Bit Values
//
#define CONFIG_DSM2           (0x01)    // Enable DSM2 Satellite Receiver (instead of GPS)

//////////////////////////////////////////////////////////////////////////////////////////
//
//             initializeI2CSensor(TSensors nPortIndex, const bool bFastI2C)
//
// Initializes an I2C sensor. 'bFastI2C' is a flag to indicate whether standard speed I2C
// (i.e. one byte transferred every 1 to 2 milliseconds using 12 KHz clock) or fast speed
// transmission should be used with the sensor.
//
// Fast speed is about five times faster than standard. It is suitable for sensors that
// have hardware I2C support rather than a bit-banged I2C implementation.
//
//////////////////////////////////////////////////////////////////////////////////////////
void initializeI2CSensor(const tSensors nPortIndex, const bool bFastI2C)
{
  SensorType[nPortIndex] = bFastI2C ? sensorI2CCustomFast : sensorI2CCustom;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//                waitForI2CReply(TSensors nPortIndex, const int nReplyLength)
//
// Function will delay waiting for last I2C transaction to finish.
//
//////////////////////////////////////////////////////////////////////////////////////////
bool waitForI2CReply(tSensors nPortIndex, const int nReplyLength)
{
	while (nI2CStatus[nPortIndex] == STAT_COMM_PENDING)
		wait1Msec(1);

	if (nI2CBytesReady[nPortIndex] != nReplyLength)
		return false;

	return true;
}


//
// Alternate version showing more complicated error checking
//
bool checkErrorStatus(tSensors nPortIndex, const int nReplyLength)
{
	while (nI2CStatus[nPortIndex] == STAT_COMM_PENDING)
		wait1Msec(1); // Waiting for I2C transaction to complete

	//
	// Handle all possible return status. You may want to customize the
	// code for your particular situation.
	//
	switch (nI2CStatus[nPortIndex])
	{
	case NO_ERR:
		return true;

	case STAT_COMM_PENDING:
		// Shouldn't reach here because of preceding 'while' clause
		return false;

	case ERR_COMM_CHAN_NOT_READY:
		// Sensor is not configured for I2C messaging.
		return false;

	case ERR_COMM_BUS_ERR:
		// re-initialize sensor. An I2C messaging error occurred.
		return false;

	default:
		// "Illegal" value
		return false;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//                        Send a Message via I2C
//
// Sends an arbitrary (up to) 4-byte message over an I2C port.
//
// You'll have to poll the status of the I2C communications channel to tell when the
// I2C transaction is complete.
//
// Usually when writing to device the reply length will be zero.
//
//////////////////////////////////////////////////////////////////////////////////////////
bool sendI2CMessage(tSensors nPortIndex, const ubyte kRegisterIndex, const ubyte NBytes, const ubyte nByte1, const ubyte nByte2, const ubyte nByte3, const ubyte nByte4)
{
  const ubyte nMsg[] =
	{
		2 + NBytes,          // This is length field for transmitted message.
		ARDUNXT_I2C_ADDR,    // The I2C address of the device.
		kRegisterIndex,      // The internal register index within the sensor to start writeing at.
		nByte1,
		nByte2,
		nByte3,
		nByte4
	};

	if (nI2CStatus[nPortIndex] == STAT_COMM_PENDING)
		return false;   // Can't send message to a busy device

	sendI2CMsg(nPortIndex, nMsg[0], 0);
	return true;
}




//////////////////////////////////////////////////////////////////////////////////////////
//
//                           Read from an I2C Device
//
// Sends a message to I2C sensor to read data from the device. You'll have to poll the
// status of the I2C communications channel to tell when the 'read' is complete.
//
//////////////////////////////////////////////////////////////////////////////////////////

bool sendSensorRead(tSensors nPortIndex, const ubyte &nSendMsg, const int nReplyLength)
{
	if (nI2CStatus[nPortIndex] == STAT_COMM_PENDING)
		return false;   // Can't send message to a busy device

	sendI2CMsg(nPortIndex, nSendMsg, nReplyLength);
	return true;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//                        readI2CReply(TSensors nPortIndex)
//
// Collects the reply bytes from an I2C message.
//
//////////////////////////////////////////////////////////////////////////////////////////

bool readSensorReply(tSensors nPortIndex, ubyte &pReplyMsg, const int nReplyLength)
{
	if (!waitForI2CReply(nPortIndex, nReplyLength))
	{
	  return false;
	}

	readI2CReply(nPortIndex, pReplyMsg, nReplyLength);
	return true;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//          Read GPS Data Block from ArduNXT
//
////////////////////////////////////////////////////////////////////////////////////////////
static ubyte nGPSReply[ARDUNXT_GPSSIZE];

void ArduNXTReadGPS(tSensors nPortIndex)
{
	static const ubyte nMsg[] =
	{
		2,                   // This is length field for transmitted message.
		ARDUNXT_I2C_ADDR,    // The I2C address of the device.
		ARDUNXT_GPSDATA      // The internal register index within the sensor to start reading from
	};

	const int kReplyLength = ARDUNXT_GPSSIZE;
//ubyte nGPSReply[kReplyLength];

  while (!sendSensorRead(nPortIndex, nMsg, kReplyLength))
  {
    // wait until we can send the request to read data
  }

  int nReadTime = nSysTime;

  while (!readSensorReply(nPortIndex, (ubyte *)nGPSReply, kReplyLength))
  {
    // wait for reply to arrive
    if ((nSysTime - nReadTime) > 100)
    {
      // if we haven't got a reply after 100mS then we are not going to get one.
      break;
    }
    wait1Msec(1);
  }

  // Signed values
  {
    long lTime;
    lTime = nGPSReply[0] | (nGPSReply[1]<<8) | (nGPSReply[2]<<16) | (nGPSReply[3]<<24);

    nxtDisplayTextLine(3, "T:%ldmS", lTime);
  }
}


/**
 * Get the Remote Control Channel values.
 * @param link the ArduNXT port number
 * @param pu16RCValues array into which the Remote Control Input pulse widths are to be written
 * @param numChannels the number of Remote Control Input Channels to read
 */
bool ArduNXTReadRemoteControl(tSensors link, int &pu16RCValues, ubyte numChannels)
{
	static const ubyte nMsg[] =
	{
		2,                   // This is length field for transmitted message.
		ARDUNXT_I2C_ADDR,    // The I2C address of the device.
		ARDUNXT_RC_CHAN1     // The internal register index within the sensor to start reading from
	};

  int nReadTime = nSysTime;

  if (numChannels > MAX_NUM_RCCHANNELS)
  {
    // Request to read too many channels
    return false;
  }

  while (!sendSensorRead(link, nMsg, numChannels<<1))
  {
    // wait until we can send the request to read data
    if ((nSysTime - nReadTime) > 100)
    {
      // if we haven't been able to send after 100mS then we are not going to.
      return false;
    }
    wait1Msec(1);
  }

  nReadTime = nSysTime;
  while (!readSensorReply(link, (ubyte *)pu16RCValues, numChannels<<1))
  {
    // wait for reply to arrive
    if ((nSysTime - nReadTime) > 100)
    {
      // if we haven't got a reply after 100mS then we are not going to get one.
      return false;
    }
    wait1Msec(1);
  }
  return true;
}


// Send 4 Servo Positions using the Quick Registers with units of 10uS
// For other Servo control functionality please see NXTServo-driver.h
bool ArduNXTSendServo(tSensors nPortIndex, ubyte nByte1, ubyte nByte2, ubyte nByte3, ubyte nByte4)
{
  int nReadTime = nSysTime;

  while (!sendI2CMessage(nPortIndex, ARDUNXT_QPOS_CHAN1, 4, nByte1, nByte2, nByte3, nByte4))
  {
    // wait until we can send the data
    if ((nSysTime - nReadTime) > 100)
    {
      // if we haven't been able to send after 100mS then we are not going to.
      return false;
    }
    wait1Msec(1);
  }
  return true;
}

// Send Configuration Byte to ArduNXT
bool ArduNXTSendConfig(tSensors nPortIndex, ubyte nByte1)
{
  int nReadTime = nSysTime;

  while (!sendI2CMessage(nPortIndex, ARDUNXT_CONFIG, 1, nByte1, 0, 0, 0))
  {
    // wait until we can send the data
    if ((nSysTime - nReadTime) > 100)
    {
      // if we haven't been able to send after 100mS then we are not going to.
      return false;
    }
    wait1Msec(1);
  }
  return true;
}


task main()
{
	int    u16RC[MAX_NUM_RCCHANNELS];             // 4 Remote Control Input Channels
  ubyte  u8Servo[4];

  // Initialisation
  u8Servo[0] = 150;
  u8Servo[1] = 150;
  u8Servo[2] = 150;
  u8Servo[3] = 150;

  initializeI2CSensor(ArduNXT, true);
  ArduNXTSendConfig(ArduNXT, CONFIG_DSM2);
  ArduNXTSendServo(ArduNXT, u8Servo[0], u8Servo[1], u8Servo[2], u8Servo[3]);
  nxtDisplayBigTextLine(0, "ArduNXT");

  // Monitoring Loop
  while (true)
  {
    // Read Remote Control Inputs
    if (ArduNXTReadRemoteControl(ArduNXT, u16RC,  MAX_NUM_RCCHANNELS))
    {
      // Display the values
       nxtDisplayTextLine(4, "0:%4d 4:%4d", u16RC[0], u16RC[4]);
       nxtDisplayTextLine(5, "1:%4d 5:%4d", u16RC[1], u16RC[5]);
       nxtDisplayTextLine(6, "2:%4d 6:%4d", u16RC[2], u16RC[6]);
       nxtDisplayTextLine(7, "3:%4d uS", u16RC[3]);
    }
    else
    {
       nxtDisplayTextLine(4, "No Response!!!");
       nxtDisplayTextLine(5, "No Response!!!");
       nxtDisplayTextLine(6, "No Response!!!");
       nxtDisplayTextLine(7, "No Response!!!");
    }

    // Control Servo Outputs (based on the RC Inputs)
    // Reversed - so that you can tell the difference between direct RC control and ArduNXT control
    if (u16RC[0])    u8Servo[0] = 300-(u16RC[0]/10);  // 500 - 1500 - 2500: 50 - 150 - 250: 250 - 150 - 50
    if (u16RC[1])    u8Servo[1] = 300-(u16RC[1]/10);
    if (u16RC[2])    u8Servo[2] = 300-(u16RC[2]/10);
    if (u16RC[3])    u8Servo[3] = 300-(u16RC[3]/10);

    if (ArduNXTSendServo(ArduNXT, u8Servo[0], u8Servo[1], u8Servo[2], u8Servo[3]))
    {
      nxtDisplayTextLine(2, "Servo 0:%3d0 uS", u8Servo[0]);
    }
    else
    {
      nxtDisplayTextLine(2, "No Response!!!");
    }

    // Read the GPS Data
    // ArduNXTReadGPS(ArduNXT);

    wait1Msec(10);
  }
}
